# Module 1

https://github.com/privacy-scaling-explorations/core-program/blob/main/2024/week1_cryptographic_basics.md

## **Symmetric vs Asymmetric Encryption**

Encryption is a technique used to encode data, making it readable only to those who possess the correct decryption key.

### **Symmetric Encryption**

- Also known as single-key encryption
- Use the same key for both encryption and decryption.
- Most used symmetric encryption algorithm is Advanced Encryption Standard (AES)
- **Pros:**
    - **Faster:** Since it’s using a single key for encryption and decryption, it’s faster to execute.
    - **Identity verification:** It uses password authentication as a security purpose to prove the receiver’s identity.
    - **Easy to execute & manage:** Users have only one key for encryption and decryption so it’s easy to execute and manage.
- Cons:
    - The chances of sharing encryption keys securely are less; it is difficult and challenging to share keys in Symmetric Encryption.
    - Symmetric is not that scalable, as it’s not suitable for various users.

### **Asymmetric Encryption**

- Also known as public-key encryption
- Uses a pair of keys: one for encryption and another for decryption.
- The RSA algorithm is one of the best known public-key algorithms
- Pros:
    - Asymmetric Encryption has two keys, one public and one private, so there’s no problem with distributing keys.
    - It is not difficult to communicate with multiple parties and that’s how it is more scalable in large networks.
- Cons:
    - **Performance:** Asymmetric Encryption is slower in performance compared to Symmetric Encryption.
    - **Hard to understand and execute:** Asymmetric Encryption is not that easy to implement and manage due to its large key sizes.

### **Difference Between Symmetric and Asymmetric Encryption**

| Key Differences | Symmetric Encryption | Asymmetric Encryption |
| --- | --- | --- |
| Size of cipher text | Smaller cipher text compares to original plain text file. | Larger cipher text compares to original plain text file. |
| Data size | Used to transmit big data. | Used to transmit small data. |
| Resource Utilization | Symmetric key encryption works on low usage of resources. | Asymmetric encryption requires high consumption of resources. |
| Key Lengths | 128 or 256-bit key size. | RSA 2048-bit or higher key size. |
| Security | Less secured due to use a single key for encryption. | Much safer as two keys are involved in encryption and decryption. |
| Number of keys | Symmetric Encryption uses a single key for encryption and decryption. | Asymmetric Encryption uses two keys for encryption and decryption |
| Techniques | It is an old technique. | It is a modern encryption technique. |
| Confidentiality | A single key for encryption and decryption has chances of key compromised. | Two keys separately made for encryption and decryption that removes the need to share a key. |
| Speed | Symmetric encryption is fast technique | Asymmetric encryption is slower in terms of speed. |
| Algorithms | RC4, AES, DES, 3DES, and QUAD. | RSA, Diffie-Hellman, ECC algorithms. |

## Hash Functions

A hash function takes an input and returns a fixed-size string of bytes. 

**SHA-256** and **Poseidon** are popular cryptographic hash functions in our context.

Primary characteristics:

- **Preimage Resistance**: It's difficult to reverse-engineer the original input from its hash.
- **Second Preimage Resistance**: It’s hard to find a different input that produces the same hash as a given input.
- **Collision Resistance**: It's tough to find two different inputs that hash to the same value.

### What Is SHA-256 Algorithm & How It Works

 Is a cryptographic hash function that generates a 256-bit fixed-size hash value from any input data

It works by processing the input data in blocks of 512 bits, using a series of logical operations, bitwise shifts, and modular additions.

The algorithm applies several rounds of these operations to produce a unique and fixed-length hash value.

### How is SHA-256 used in blockchain, and why?

It is employed at various stages within a blockchain:

- **Consensus Mechanism**: Miners calculate the hash of new blocks using SHA-256 by varying the value of a nonce in a Bitcoin block until they find a hash below a specific threshold. This process, known as proof of work, allows the block to be accepted into the ledger.
- **Chains of Blocks**: Each block in the blockchain contains a hash generated by SHA-256 that refers to the preceding block in the chain. This linking of blocks creates a secure and immutable ledger.
- **Digital Signatures**: Transactions use digital signatures to maintain integrity. The information used in the transaction is hashed using SHA-256, and then encrypted with the sender's private key to generate a signature. Miners then verify this signature to validate the transaction.

### What Makes SHA-256 an Ideal Candidate for Blockchain?

SHA-256 offers several key features that make it perfect for use as the main hashing function in a blockchain:

1. **Collision Resistant**: No two different input values can produce the same hash output. This ensures that each block in the blockchain ledger is assigned a unique hash value, maintaining the integrity of the ledger.
2. **Preimage Resistance**: It is computationally infeasible to recreate the original input from a given hash value. This ensures that miners cannot reverse-engineer the nonce value during proof of work, necessitating a brute force approach and ensuring the required computational effort.
3. **Deterministic**: The hash function's output remains the same for a given input. This consistency is crucial for digital signatures, as both sender and receiver must compute the same hash for a given transaction.
4. **Large Output**: The 256-bit output of SHA-256 provides 2^256 possible hash values, making it practically impossible to use brute force to crack the hash.
5. **Avalanche Effect**: A small change in the input results in a significantly different output. This ensures that the hash value cannot be easily guessed based on the input values, enhancing security.

### Poseidon: A new hash function for zero-knowledge proof systems

**Poseidon** is a cryptographic hash function designed specifically for zero-knowledge proof systems. It is optimized for arithmetic-friendly operations, making it more efficient in environments where traditional hash functions like SHA-256 are less performance.

Poseidon's design allows for faster proof generation and verification, which is crucial for applications in blockchain and other privacy-preserving technologies.

### What are the primary uses of a hash function in cryptography?

- **Data integrity**: Verifying that data has not been altered.
- **Authentication**: Ensuring that a message or data comes from a legitimate source.
- **Digital signatures**: Creating a unique representation of data for secure transactions.
- **Cryptographic protocols**: Supporting various security protocols and mechanisms.

### How does the SHA-256 hashing algorithm function, in simple terms?

**SHA-256** takes an input and processes it through a series of steps to produce a 256-bit hash value.

The input is divided into 512-bit blocks and processed using logical operations, bitwise shifts, and modular additions.

The algorithm applies these operations iteratively, mixing the input data thoroughly, resulting in a fixed-length hash that uniquely represents the original data.

### Why Poseidon is a particularly useful in ZKPs?

Poseidon's structure allows for faster and more efficient proof generation and verification, making it particularly useful in applications where performance and scalability are critical, such as in blockchain and privacy-preserving technologies.

## Merkle Trees

A Merkle tree is a core component of blockchain and cryptography. It's a binary tree filled with cryptographic hashes. This structure enables efficient and secure verification of the contents of large data structures.

### How Merkle Trees Enable the Decentralized Web?

Merkle Trees play a vital role in the decentralized web by ensuring data integrity and enabling efficient verification processes. They allow decentralized systems to securely manage and verify large datasets without relying on a central authority. By using Merkle Trees, decentralized applications and platforms can:

- Ensure data integrity and immutability.
- Efficiently verify data authenticity with minimal bandwidth and storage requirements.
- Support lightweight clients that do not need to download entire datasets.

### Merkle Trees and Merkle Roots Explained

A **Merkle Tree** is a binary tree where each leaf node contains the hash of a data block, and each non-leaf node contains the hash of its child nodes.

The **Merkle Root** is the topmost node of the tree and uniquely represents the entire dataset. This structure allows for secure and efficient verification of data integrity. If any part of the data changes, the Merkle Root will also change, indicating tampering or data corruption.

### Visualizing Efficient Merkle Trees for Zero-Knowledge Proofs

Merkle Trees enable efficient proof generation and verification. A Merkle Tree allows a prover to demonstrate that a piece of data is part of a larger dataset without revealing the entire dataset. This is done using Merkle Proofs, which consist of a series of hashes that link the data to the Merkle Root. This method is computationally efficient and maintains privacy.

### Can you describe the structure of a Merkle tree?

- **Leaf Nodes**: Each leaf node contains the hash of a data block.
- **Intermediate Nodes**: Each intermediate node contains the hash of the concatenation of its two child nodes.
- **Merkle Root**: The topmost node, which is the hash of the concatenation of its two child nodes (or the single node in case of an odd number of nodes at the previous level).

### How are Merkle trees used within the blockchain context?

- **Transaction Verification**: Each block in the blockchain contains a Merkle Tree of all its transactions. The Merkle Root is included in the block header, allowing nodes to verify transactions without downloading the entire block.
- **Efficient Light Clients**: Light clients store only the block headers and use Merkle Proofs to verify specific transactions, reducing the need for extensive storage and bandwidth.
- **Ensuring Data Integrity**: By linking each block to the previous one via their Merkle Roots, blockchains ensure that any tampering with transaction data can be easily detected.

### Why are Merkle trees useful for efficient and secure verification of large data structures?

- **Scalability**: They allow large datasets to be verified efficiently with minimal data. Only a small number of hashes (logarithmic to the number of leaf nodes) are needed to verify any single piece of data.
- **Tamper-Proof**: Any change to the underlying data results in a different Merkle Root, making it easy to detect alterations.
- **Proof of Inclusion**: Merkle Proofs enable the verification of specific pieces of data without requiring access to the entire dataset, ensuring both security and efficiency.
- **Bandwidth and Storage Efficiency**: By reducing the amount of data needed for verification, Merkle Trees make decentralized systems more practical and scalable.

## **Digital Signatures**

Digital signatures are a way to ensure the integrity and authenticity of digital messages or documents. They work like a handwritten signature or a seal, but they are much more secure. 

Digital signatures provide a way to verify that a message or document was created by a known sender (authentication) and that it was not altered in transit (integrity).

### Why are Digital Signatures Essential in Digital Communications?

- **Verify Identity**: Ensure that the message or document is from a legitimate sender.
- **Ensure Integrity**: Confirm that the content has not been changed or tampered with.
- **Non-repudiation**: The sender cannot deny having sent the message or document, as the signature uniquely identifies them.

### How Do Digital Signatures Work?

- **Private Key and Public Key**: In a digital signature system, each user has a pair of keys – a private key (kept secret) and a public key (shared with everyone).
- **Signing a Message**: The sender uses their private key to generate a signature on the message.
- **Verifying a Signature**: The recipient (or anyone) can use the sender's public key to verify the signature. If the verification is successful, it confirms that the message is from the sender and has not been altered.

## Schnorr Signatures

Schnorr signatures are a type of digital signature known for their simplicity and efficiency. They use mathematical algorithms to create a secure and verifiable signature. Here's a simple breakdown:

1. **Key Generation**: Each user generates a private key and a corresponding public key.
2. **Signing**: The sender creates a signature for a message using their private key. This involves combining the private key with a random value and the message itself.
3. **Verification**: The recipient uses the sender's public key to verify the signature. If the verification process confirms the signature, the message is considered authentic and unaltered.

## Digital Signature Algorithm (DSA)

### How Does the Digital Signature Algorithm (DSA) Work?

1. **Key Generation**: Similar to other digital signature schemes, DSA involves generating a pair of keys – a private key and a public key.
2. **Signing**:
    - The sender creates a digital signature using their private key. This process involves creating a hash of the message and then using the private key to generate a unique signature.
3. **Verification**:
    - The recipient uses the sender's public key to verify the signature. This involves checking that the signature corresponds to the message and the public key.
    - If the verification is successful, it confirms that the message is from the sender and has not been altered.

### Why is DSA Important?

DSA is important because it:

- **Provides Security**: Ensures that messages and documents are authentic and have not been tampered with.
- **Supports Internet Security**: Widely used in various internet security protocols, including SSL/TLS for secure web browsing.

## DLP-based Public-Key Cryptography

The **Discrete Logarithm Problem (DLP)** is a difficult mathematical problem that forms the basis of several public-key cryptographic systems. It involves finding the exponent in the equation g**^x = h mod p**, where:

- g is a known base (a generator),
- h is a known result,
- p is a large prime number,
- x is the exponent (or logarithm) we need to find.

The difficulty of solving DLP makes it a secure foundation for cryptographic algorithms.

### How does the Diffie-Hellman Protocol Work?

The **Diffie-Hellman Key Exchange** is a method for two parties to securely share a secret key over an insecure channel. Here's a simple breakdown:

1. **Public Parameters**: Both parties agree on a large prime number p and a base g.
2. **Private Keys**: Each party chooses a private key (a for Alice and b for Bob) and keeps it secret.
3. **Compute Public Keys**:
    - Alice computes her public key as A=g**^**a mod p.
    - Bob computes his public key as B=g**^**b mod p.
4. **Exchange Public Keys**: Alice and Bob exchange their public keys A and B.
5. **Compute Shared Secret**:
    - Alice computes the shared secret as
        
        s=B**^**a \mod  p p
        
    - Bob computes the shared secret as
        
        s = A^b \mod p
        

Both Alice and Bob now have the same shared secret sss, which can be used to encrypt and decrypt messages.

### Can You Name a Drawback of Using DLP-based Systems?

A drawback of using DLP-based systems is that they require larger key sizes to achieve the same level of security as other cryptographic systems like RSA. This can result in:

- **Increased Computational Requirements**: Larger key sizes mean more processing power and time are needed for encryption and decryption.
- **Higher Storage Needs**: Storing larger keys requires more memory.
- **More Bandwidth Consumption**: Transmitting larger keys can consume more bandwidth in communication systems.

## **Cryptographic Commitments**

Are a way to securely hide and later reveal information. They are crucial in cryptography and blockchain technology for maintaining data privacy and enabling verification.

### Key Features

1. **Selective Hiding and Revealing**: Commitments allow you to hide information until you choose to reveal it.
2. **Verification**: Even while hidden, the commitment can be used to verify certain properties without revealing the actual information.

### How They Work

1. **Commit**: You create a commitment by combining the information you want to hide with a random value (called a "nonce"). This produces a commitment value that you can share without revealing the original information.
2. **Open (Reveal)**: Later, you can reveal the original information and the nonce. The verifier can use these to check that the commitment value matches the original information, ensuring it hasn't been altered.

### In Blockchain:

- **Transactions**: In blockchain, commitments can hide sensitive transaction details or user identities. When needed, specific details can be revealed to verify the transaction while keeping other information private.

![Untitled](Module%201%2026cc4a35cf904d7c905403d5fc105ef9/Untitled.png)